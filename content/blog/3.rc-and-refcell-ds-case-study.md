---
title: "Understanding Rc and RefCell in Rust"
description: "A Case Study with Tree Structures"
date: "2025-03-22T10:01:28.409Z"
tags:
  - rust
  - programming
  - data-structures
---

Rust's memory management model is one of its most powerful features, but it also presents unique challenges for beginners. Unlike languages with garbage collection, Rust enforces strict ownership and borrowing rules at compile time. However, there are cases where we need more flexibilityâ€”especially when dealing with tree structures or graphs where multiple owners of a value exist. This is where `Rc<T>` (Reference Counting) and `RefCell<T>` (Interior Mutability) come in.

In this post, we'll break down `Rc` and `RefCell` using a real-world example: building a tree from a list of parent-child relationships.

## The Challenge: Building a Tree from a Graph

Consider a tree structure where each node has a value and can have multiple children. In Rust, we need to manage ownership correctly so that parent nodes can own their children while ensuring children don't get dropped prematurely.

Let's say we have a list of edges representing a tree:

```rust
let graph = vec![(0, 1), (0, 2), (1, 3), (3, 4)];
```

This represents a hierarchy where `0` is the root, `0` has children `1` and `2`, and so on. The challenge is converting this into an actual tree structure.

## Why Can't We Use Plain Structs?

A naive approach might define a `Node` struct with a `Vec<Node>` for children:

```rust
struct Node {
    value: i8,
    children: Vec<Node>,
}
```

However, this runs into ownership issues. When a node is part of `Vec<Node>`, it is _owned_ by the vector. If another parent wants to reference the same child, Rust's ownership rules won't allow it.

## Solution: Using Rc and RefCell

We solve this problem by:

- Wrapping `Node` in `Rc<T>` (Reference Counting) to allow multiple owners.
- Using `RefCell<T>` (Interior Mutability) to allow modifying the children inside an immutable `Rc<Node>`.

### Final Implementation

```rust
use std::collections::HashMap;
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i8,
    children: Vec<Rc<RefCell<Node>>>,
}

impl Node {
    fn new(value: i8) -> Rc<RefCell<Self>> {
        Rc::new(RefCell::new(Node {
            value,
            children: vec![],
        }))
    }

    fn adopt(&mut self, node: Rc<RefCell<Node>>) {
        self.children.push(node);
    }

    fn depth(&self, level: i32) -> i32 {
        if self.children.is_empty() {
            return level;
        }
        self.children
            .iter()
            .map(|child| child.borrow().depth(level + 1))
            .max()
            .unwrap_or(level)
    }
}

fn arr_notation_to_nodes(graph: Vec<(i8, i8)>) -> Rc<RefCell<Node>> {
    let mut node_map: HashMap<i8, Rc<RefCell<Node>>> = HashMap::new();

    for (parent, child) in graph {
        let parent_node = node_map.entry(parent).or_insert_with(|| Node::new(parent)).clone();
        let child_node = node_map.entry(child).or_insert_with(|| Node::new(child)).clone();

        parent_node.borrow_mut().adopt(child_node);
    }

    node_map[&graph[0].0].clone()
}

fn main() {
    let graph = vec![(0, 1), (0, 2), (1, 3), (3, 4)];
    let root = arr_notation_to_nodes(graph);
    println!("Tree Depth: {}", root.borrow().depth(0));
}
```

## Breaking Down the Solution

### 1. `Rc<T>` for Shared Ownership

`Rc<T>` (Reference Counting) allows multiple parts of our program to share ownership of a `Node`. This is essential because child nodes can have multiple references in different parent nodes.

```rust
Rc::new(RefCell::new(Node { value, children: vec![] }))
```

Each node is wrapped inside `Rc` so that it can be cloned and shared without moving ownership.

### 2. `RefCell<T>` for Interior Mutability

Since `Rc<T>` only allows shared ownership and doesn't support mutation, we wrap the `Node` inside `RefCell<T>`. This lets us mutate the children of a node even if it's wrapped in an `Rc<T>`.

```rust
parent_node.borrow_mut().adopt(child_node);
```

Here, `.borrow_mut()` gives us a mutable reference to modify the `children` vector.

### 3. Building the Tree

The function `arr_notation_to_nodes` creates nodes only if they don't already exist in the `HashMap`. Then it establishes parent-child relationships by calling `adopt()`.

## Why This Works in Rust

Without `Rc<RefCell<Node>>`, Rust's strict ownership model would make it impossible to have multiple references to the same child node. `Rc` allows multiple owners, and `RefCell` enables interior mutability while keeping the borrow checker happy.

## Summary

- `Rc<T>` enables shared ownership of a value.
- `RefCell<T>` allows interior mutability.
- `Rc<RefCell<T>>` together let us build tree structures with dynamically changing children.
- This pattern is useful for graphs, trees, and scenarios where multiple owners need mutable access.

If you're new to Rust (like me), `Rc` and `RefCell` might seem complex at first, but once you understand their purpose, they become invaluable tools. The key takeaway is that they provide flexibility while maintaining Rust's memory safety guarantees.

